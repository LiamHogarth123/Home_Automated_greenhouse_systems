classdef Lab2ClassTest <handle
    %UNTITLED4 Summary of this class goes here
    %   Detailed explanation goes here

    properties
        robot1 %object for the LinearUR3 so i can call it in other functions
        UR5Grip %object for the Gripper so i can call it in other functions
        robot2 %object for the LinearUR3 so i can call it in other functions
        A0509Grip %object for the Gripper so i can call it in other functions
        Plants
        i
    end

    methods
    
        function self = Lab2ClassTest()
            clf;
            hold on;
            self.robot1 = LinearUR5;
            self.robot1.model;
            self.UR5Grip = UR5_Gripper;
            self.robot2 = A0509;
            self.robot2.model;
            self.A0509Grip = A0509_Gripper;
            SpawnGreenhouseEnvironment();
            self.placePlants();
            self.PlacePlantOnTable();
           

        end

    end

    methods(Static)
        
        function placePlants()
             %these brick are in a lined up configuration 
            Plant_Position = zeros(6,3);
            Plant_Position(1,:) =[0.12,0.6, 0.3];
            Plant_Position(2,:) =[0.02, 0.6, 0.3];
            Plant_Position(3,:) =[-0.1,0.6,0.3];
            Plant_Position(4,:) =[-0.2, 0.6, 0.3];
            Plant_Position(5,:) =[-0.3, 0.6, 0.3];
            Plant_Position(6,:) =[-0.4, 0.6, 0.3];
            Plant_Position(7,:) =[-0.5,0.6,0.6];
            Plant_Position(8,:) =[-0.6,0.6,0.6];
            Plant_Position(9,:) =[-0.7,0.6,0.6];
            [f,v,data] = plyread('Plant.ply','tri');

            % Scale the colours to be 0-to-1 (they are originally 0-to-255
            vertexColours = [data.vertex.red, data.vertex.green, data.vertex.blue] / 255;
            BrickVectCount = size(v,1);
            hold on;
            %place object function
            for i= 1:size(Plant_Position, 1)
                self.Plants(i) = trisurf(f,v(:,1)+ Plant_Position(i,1),v(:,2)+ Plant_Position(i,2), v(:,3) +Plant_Position(i,3)...
                    ,'FaceVertexCData',vertexColours,'EdgeColor','interp','EdgeLighting','flat');
            end
            camlight;
            hold on;
        end

   


        function PlacePlantOnTable()
            %% placing bricks on table
            
            offset = 0;
            steps = 50;
    

            Table_Position = zeros(6,3);
            Table_Position(1,:) =[0.25, 0.15, 0.5];
            Table_Position(2,:) =[0.25, 0,0.5];
            Table_Position(3,:) =[0.25,-0.15,0.5];
            Table_Position(4,:) =[0.25,0.15,0.525];
            Table_Position(5,:) =[0.25,0,0.525];
            Table_Position(6,:) =[0.25,-0.15,0.525];
            Table_Position(7,:) =[0.25,0.15,0.55];
            Table_Position(8,:) =[0.25,0,0.55];
            Table_Position(9,:) =[0.25,-0.15,0.55]; 

            Plant_Position = zeros(6,3);
            Plant_Position(1,:) =[0.12,0.6, 0.3];
            Plant_Position(2,:) =[0.02, 0.6, 0.3];
            Plant_Position(3,:) =[-0.1,0.6,0.3];
            Plant_Position(4,:) =[-0.2, 0.6, 0.3];
            Plant_Position(5,:) =[-0.3, 0.6, 0.3];
            Plant_Position(6,:) =[-0.4, 0.6, 0.3];
            Plant_Position(7,:) =[-0.5,0.6,0.6];
            Plant_Position(8,:) =[-0.6,0.6,0.6];
            Plant_Position(9,:) =[-0.7,0.6,0.6];


            
            for i= 1:size(Plant_Position, 1)
                %%get brick -----------------------------------------------------

                %stores the current brick's position while adding a offset for the
                Current_Plant = Plant_Position(i,:);
                Current_Plant(3) = Current_Plant(3) + offset;
        
                %reads the current position
                current_position = robot.model.getpos();
                
                %calculates the required translation
                requiredTranslation = transl(Current_Plant) * troty(90,'deg')* trotx(90,'deg');
        
                %caclutes the required q angles for the final position
                PlantInverseKnimatics = robot.model.ikcon(requiredTranslation, current_position);
                
                %finds the required step to animate the robot
                Brick_trajectory = jtraj(current_position, PlantInverseKnimatics, steps);
                
                %loops through animation
                for j = 1:size(Brick_trajectory,1)
                    x = Brick_trajectory(j,:);
                    robot.model.animate(x);
                    pause(0.1);
              
                end
        
                %deletes the brick from the start position to prepare for it to
                %move with the ar,
                
                delete(Plants(i))
                
                
           
        
            % ---------------------------------------------------------------------------------------
                %This section deliever the brick the wall position
              
                %updates the current position
                current_position = robot.model.getpos();
            
                %updates the internal variable for the final position with offset
                Goal = Table_Position(i,:);
                Goal(3) = Goal(3) + brickoffset;
        
                %calculate the translation, invserse kinematics, and trajectory
                requiredTranslation = transl(Goal) * troty(90,'deg')*trotx(90,'deg');
                deliever_brickikine = robot.model.ikcon(requiredTranslation, current_position);
                Brick_trajectory = jtraj(current_position, deliever_brickikine, steps);
                
                %loops through the animation
                for k = 1:size(Brick_trajectory,1)
                    x = Brick_trajectory(k,:);
                    robot.model.animate(x);
                    pause(0.25);
        
              
                    %
                    Brick_pose = robot.model.fkine(Brick_trajectory(k,:));
                    Brick_pose.t(3) = Brick_pose.t(3) - brickoffset;
                    delete(Plants(i))
                    
                    drawnow();  
                
        %       % cow method -----------
        %             cow.cowModel{1}.base = robot.model.fkine(robot.model.getpos());
        %             cow.cowModel{1}.animate(0);
        %             drawnow();
        
          
                end
                
                 
            
        
        
                %deletes the brick off the robotic arm
                delete(self.Plants(i))
                
                %This code places the brick at it's final location building the
                %wall
                Goal = Table_Position(i,:);
                trisurf(f,v(:,1)+ Goal(1),v(:,2)+ Goal(2), v(:,3) +Goal(3)...
                    ,'FaceVertexCData',vertexColours,'EdgeColor','interp','EdgeLighting','flat');
            end


        end
    end
end